// Code generated by a2q version 1.0 please report any bugs to jpc485@nyu.edu
// ***** Aquery utilities ***** ///
//table related
.aq.gencd:{[t;sn;m] ((`$(sn,"."),/:sc),c)!(2*count c)#`$($[m;sn,"__";""]),/:sc:string c:cols t}
.aq.rcols:{[t;p] (`$(p,"__"),/:string cols t) xcol t};
.aq.ju:{[cs;j] $[2<>count m:cs where cs like "*__",s:string j;'"ambig-join:",s;`rename`remap!(m!2#n;((.aq.cd?m),j)!(1+count m)#n:`$"_"sv string m)]}
.aq.scbix:{[v] m[`c] iasc `s`p`g`u?(m:0!meta v)`a}; //sort column names by attribute
// swix below not yet implemented due to bugs occurring
//.aq.swix:{[v;w] w iasc .aq.scbix[v]?w@'where each type[`]=(type each) each w} //sort where clause by attributes of cols used
.aq.swix:{[v;w] w}
.aq.negsublist:{[x;y] neg[x] sublist y}
.aq.chkattr:{[x;t] any (.aq.cd where any each flip .aq.cd like/: "*",/:string (),x) in exec c from meta t where not null a}
.aq.acctgrps:{[p;g] @[p;key[p] ix;:;key[g] raze where each c ix:where any each c:value[p]~/:\:value g]}
 //full outer join using (definition compliant with traditional sql semantics
k).aq.ejix:{(=x#z:0!z)x#y:0!y} // from ej
.aq.foju:{
  nix:.aq.ejix[x:(),x;y:0!y;z:0!z];
  iz:raze nix; //indices in z for equijoin
  iy:where count each nix; // indices in y for equijoin
  ejr:y[iy],'(x _ z) iz; // perform equi join
  my:select from y where not i in iy; // records in y not in equi join
  mz:select from z where not i in iz; // records z not in equi join
  ejr upsert/(my;mz) // add missing records
  }
.aq.nj:{[t1;t2;p] raze {?[x,'count[x]#enlist y;z;0b;()]}[t1; ;p] each t2}
.aq.hj:{[t1;t2;a1;a2;p]
  // argument preparation
  a1,:();a2,:();p:$[0<>type first p;enlist p;p];hasneq:any not (=)~/:first each p;
  targs:$[count[t2]>count t1;(t1;t2;a1;a2);(t2;t1;a2;a1)];
  s:targs 0;b:targs 1;sa:targs 2;ba:targs 3;
  // here the "hash function" is identity of join attributes, extract index
  bti:?[s;();sa!sa;`i];
  // hash larger and drop no matches
  bw:?[b;();ba!ba;`i];
  matches:((sa xcol key bw) inter key bti)#bti;
  // perform nj for all matches using complete join predicate
  // if has any predicate that is not equality based otherwise just cross (guaranteed matches)
  inner:b bw ba xcol key matches;
  outer:s value matches;
  $[hasneq;raze nj'[inner;outer;(count matches)#enlist p];raze {x cross y}'[inner;outer]]
 }


// Start of code
// verbatim q code

/ This script generates a csv file in the format required by the question
/ then imports that csv and does a simple query.
/ Your job is to improve on that query.
/ For this to work, you have to import q and put it in the src directory.


numdays: 100;
numstocks: 4;
dayvalues: 1 + til numdays;
stockvalues: 1000 + til numstocks;
mycross: dayvalues cross stockvalues;
ids: mycross[;1]
days: mycross[;0]
prices: (floor numdays*numstocks) ? 200
myindexes: (neg count prices) ? count prices;
ids@: myindexes;
days@: myindexes;
prices@: myindexes;
t:([]ID:ids;date:days;endofdayprice:prices)
`:ticks.csv 0:csv 0:t
delete t from `.

// create table statement
{
 `ticks set ([]ID:"i"$(); date:"i"$(); endofdayprice:"i"$())
 }[]
// load data statement
{
 `ticks set ticks upsert (upper exec t from meta ticks; enlist ",") 0:hsym `$"ticks.csv"
 }[]
.aq.q0:{[]
 .aq.pc:(); //init col names list
 .aq.cd:(`$())!`$(); //init col names map
 .aq.grpexpr:(`$())!(); //init grouped expr map
 .aq.cd:{(key[y] inter .aq.pc) _ x,y}[.aq.cd;.aq.gencd[ticks;"ticks";0b]]; //drop ambiguous cols from map
 .aq.pc:.aq.pc union cols ticks; //store orig col names to avoid collisions
 .aq.six:?[ticks;();();(iasc;{x^.aq.cd x}`date)];
 .aq.t1:![ticks;();0b;(enlist[{x^.aq.cd x}`endofdayprice]!enlist ({x^.aq.cd x}`endofdayprice; .aq.six)),(enlist[{x^.aq.cd x}`ID]!enlist ({x^.aq.cd x}`ID; .aq.six))];
 .aq.t2:?[.aq.t1;();.aq.grpexpr:(enlist[`x__0]!enlist {x^.aq.cd x}`ID);({x!x}cols .aq.t1)];
 // shadowing columns used as named groups, if want original, use correlation name
 .aq.cd:() _ .aq.cd;
 .aq.t3:?[.aq.t2;();0b; .aq.acctgrps[ ; .aq.grpexpr](enlist[`ID]!enlist {x^.aq.cd x}`ID),(enlist[`maxavgprice]!enlist (max';(mavg';3;{x^.aq.cd x}`endofdayprice)))];
 show .aq.t3;
 .aq.t3
 }
.aq.q0[]
